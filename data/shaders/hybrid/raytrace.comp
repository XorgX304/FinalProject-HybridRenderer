// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)
// Based on Sascha Willems example: https://github.com/SaschaWillems/Vulkan/tree/master/data/shaders/raytracing

#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

#define PI 3.1415926535897932384626422832795028841971
#define TWO_PI 6.2831853071795864769252867665590057683943
#define SQRT_OF_ONE_THIRD 0.5773502691896257645091487805019574556476
#define EPSILON 0.0001
#define MAXLEN 1000.0
#define TRACEDEPTH 4

// ===== STRUCT DEFINITION ===== //
struct Light {
	vec4 position;
	vec3 color;
	float radius;
};

struct Material
{
	vec4 diffuse;
	vec4 ambient;
	vec4 emission;
	vec4 specular;
	vec4 colorReflective;
	vec4 colorTransparent;
	float shininess;
	float refracti;
	float reflectivity;
};

struct Triangle
{
	int id;
	int materialId;

	vec3 vert0;
	vec3 vert1;
	vec3 vert2;

	vec3 norm0;
	vec3 norm1;
	vec3 norm2;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct PathSegment {
	Ray ray;
	vec3 color;
	int remainingBounces;
	bool shouldTerminate;
	int objectId;
};

struct Intersection {
	vec3 hitNormal;
	float t;
	vec3 hitPoint;
	int materialId;
	int objectID;
};

// ===== LAYOUT AND BINDING ===== //

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) uniform sampler2D positionsImage;
layout (binding = 1) uniform sampler2D normalsImage;
layout (binding = 2) uniform sampler2D materialIDsImage;
layout (binding = 3, rgba8) uniform writeonly image2D resultImage;

layout (std140, binding = 4) buffer TriangleIndices
{
	ivec4 indicesAndMaterialID[ ];
};

layout (std140, binding = 5) buffer TrianglePositions
{
	vec4 positions[ ];
};

layout (std140, binding = 6) buffer TriangleNormals
{
	vec4 normals[ ];
};

layout (std140, binding = 7) uniform UBO 
{
	vec4 cameraPosition;
	Light lights[6];
	int lightCount;
	int materialCount;
} ubo;


layout (std140, binding = 8) uniform Materials
{
	Material materials[10];
};




// ===== REFLECT FUNCTION ===== //

void reflectRay(inout vec3 rayD, in vec3 normal)
{
	rayD = rayD + 2.0 * -dot(normal, rayD) * normal;
}

// Lighting =========================================================

float lightDiffuse(vec3 normal, vec3 lightDir) 
{
	return clamp(dot(normal, lightDir), 0.1, 1.0);
}

float lightSpecular(vec3 cameraPosition, vec3 normal, vec3 lightDir, float specularFactor)
{
	vec3 viewVec = normalize(cameraPosition);
	vec3 halfVec = normalize(lightDir + viewVec);
	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}

// Intersection helper ===========================================================

// From StackOverflow http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

/**
 * Computes a cosine-weighted random direction in a hemisphere.
 * Used for diffuse lighting.
 */
vec3 calculateRandomDirectionInHemisphere(
    vec3 normal
	) {

    float up = sqrt(rand(vec2(0, 1))); // cos(theta)
    float over = sqrt(1 - up * up); // sin(theta)
    float around = rand(vec2(0, 1)) * TWO_PI;

    // Find a direction that is not the normal based off of whether or not the
    // normal's components are all equal to sqrt(1/3) or whether or not at
    // least one component is less than sqrt(1/3). Learned this trick from
    // Peter Kutz.

    vec3 directionNotNormal;
    if (abs(normal.x) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = vec3(1, 0, 0);
    } else if (abs(normal.y) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = vec3(0, 1, 0);
    } else {
        directionNotNormal = vec3(0, 0, 1);
    }

    // Use not-normal direction to generate two perpendicular directions
    vec3 perpendicularDirection1 =
        normalize(cross(normal, directionNotNormal));
    vec3 perpendicularDirection2 =
        normalize(cross(normal, perpendicularDirection1));

    return up * normal
        + cos(around) * over * perpendicularDirection1
        + sin(around) * over * perpendicularDirection2;
}

vec3 getPointOnRay(Ray r, float t) {
    return r.origin + (t - .0001f) * normalize(r.direction);
}

void scatterRay(
	inout PathSegment path,
	Intersection intersect
    )
{
	// Diffuse case
	vec3 scatteredRayDirection;
	Material mat = materials[intersect.materialId];
	if (mat.specular != vec4(0.0, 0.0, 0.0, 1.0)) {
		scatteredRayDirection = reflect(path.ray.direction, intersect.hitNormal);
		path.color *= vec3(mat.specular);
	} else {
		scatteredRayDirection = normalize(calculateRandomDirectionInHemisphere(intersect.hitNormal));
	}

	//path.color *= abs(dot(scatteredRayDirection, intersect.hitNormal)) * vec3(mat.diffuse);
	path.ray.direction = scatteredRayDirection;
	path.ray.origin = intersect.hitPoint + EPSILON * scatteredRayDirection;
}


// Triangle ===========================================================

void buildTriangle(int i, inout Triangle tri) {
	
	tri.id = i;
	tri.materialId = indicesAndMaterialID[i].w;
	tri.vert0 = vec3(positions[indicesAndMaterialID[i].x]);
	tri.vert1 = vec3(positions[indicesAndMaterialID[i].y]);
	tri.vert2 = vec3(positions[indicesAndMaterialID[i].z]);
	tri.norm0 = vec3(normals[indicesAndMaterialID[i].x]);
	tri.norm1 = vec3(normals[indicesAndMaterialID[i].y]);
	tri.norm2 = vec3(normals[indicesAndMaterialID[i].z]);
}

float triangleIntersect(
	in Triangle tri, 
	in Ray r,
	out vec3 normal,
	out vec3 hitPoint
	) 
{
	// Compute fast intersection using Muller and Trumbore, this skips computing the plane's equation.
	// See https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

	float t = -1.0;
	
	// Find the edges that share vertice 0
	vec3 edge1 = tri.vert1 - tri.vert0;
	vec3 edge2 = tri.vert2 - tri.vert0;

	// Being computing determinante. Store pvec for recomputation
	vec3 pvec = cross(r.direction, edge2);
	// If determinant is 0, ray lies in plane of triangle
	float det = dot(pvec, edge1);
	if (abs(det) < EPSILON) {
		return -1;
	}
	float inv_det = 1.0 / det;
	vec3 tvec = r.origin - tri.vert0;

	// u, v are the barycentric coordinates of the intersection point in the triangle
	// t is the distance between the ray's origin and the point of intersection
	float u, v;

	// Compute u
	u = dot(pvec, tvec) * inv_det;
	if (u < 0.0 || u > 1.0) {
		return -1;
	}

	// Compute v
	vec3 qvec = cross(tvec, edge1);
	v = dot(r.direction, qvec) * inv_det;
	if (v < 0.0 || (u + v) > 1.0) {
		return -1;
	}

	// Compute t
	t = dot(edge2, qvec) * inv_det;

	hitPoint = getPointOnRay(r, t);
	normal = normalize(tri.norm0 * (1 - u - v) + tri.norm1 * u + tri.norm2 * v);

	return t;
}


// Intersection ===========================================================

Intersection computeIntersections(
	inout PathSegment path
	)
{
	float tMin = MAXLEN;
	vec3 normal;
	vec3 hitPoint;
	int objectID = -1;
	int materialID = 0;
	Intersection intersection;

	// Triangles

	for (int i = 0; i < indicesAndMaterialID.length(); ++i) {
		
		if (indicesAndMaterialID[i].w == path.objectId) {
			// Skip self
			continue;
		}

		 //Reconstruct triangle
		Triangle tri;
		buildTriangle(i, tri);

		vec3 tmp_normal;
		vec3 tmp_hitPoint;
		float tTri = triangleIntersect(tri, path.ray, tmp_normal, tmp_hitPoint);
		if ((tTri > EPSILON) && (tTri < tMin))
		{
			objectID = tri.materialId;
			tMin = tTri;
			normal = tmp_normal;
			hitPoint = tmp_hitPoint;
			materialID = tri.materialId;
			path.objectId = objectID;
		}
	}

	if (objectID == -1)
	{
		intersection.t = -1.0;
	} else {
		intersection.t = tMin;
		intersection.materialId = materialID;
		intersection.hitNormal = normal;
		intersection.hitPoint = hitPoint;
		intersection.objectID = objectID;
	}

	return intersection;
}

float calcShadow(in Ray feeler, in int objectId, in float t)
{
	for (int i = 0; i < indicesAndMaterialID.length(); ++i) {
		
		if (indicesAndMaterialID[i].w == objectId) {
			// Skip self
			continue;
		}

		// Reconstruct triangle
		Triangle tri;
		buildTriangle(i, tri);

		vec3 tmp_normal;
		vec3 tmp_hitPoint;
		float tTri = triangleIntersect(tri, feeler, tmp_normal, tmp_hitPoint);
		if (tTri > EPSILON && tTri < t)
		{
			return 0.5;
		}
	}

	return 1.0;
} 

void shadeMaterial(
	in Intersection intersect,
	inout PathSegment path
	)
{
	if (intersect.t < 0.0) {
		path.remainingBounces = 0;
		return;
	}

	Material material = materials[intersect.materialId];


		for (int i = 0; i < 10; ++i) {
					
			if (i >= ubo.lightCount) {
				break;
			}

			vec3 lightVec = normalize(vec3(ubo.lights[i].position) - intersect.hitPoint);
			float dist = length(vec3(ubo.lights[i].position) - intersect.hitPoint);
		
			if (dist >= ubo.lights[i].radius) {
				continue;
			}

			// Light feeler test
			Ray feeler;
			feeler.origin = intersect.hitPoint + 0.001 * intersect.hitNormal;
			feeler.direction = lightVec;
			
			// @note: only compute shadows for the ground
			float shadow = 1;
			if (intersect.materialId == 3) {
				shadow = calcShadow(feeler, intersect.materialId, dist); 
			}
	
			// Attenuation
			float atten = ubo.lights[i].radius - dist;//ubo.lights[i].radius / (pow(dist, 2.0) + 1.0);
		
			// Diffuse195
			float diffuse = lightDiffuse(intersect.hitNormal, lightVec);
			vec3 diffuseColor = diffuse * vec3(material.diffuse);
		
			// Specular
			float specular = lightSpecular(vec3(ubo.cameraPosition), intersect.hitNormal, lightVec, 1.0);
			vec3 specularColor = specular * ubo.lights[i].color; 
		
			path.color = diffuseColor * ubo.lights[i].color;
			path.color *= shadow * atten;
		}
	
		if (material.refracti > 1.2) {
		float ei = 1.0;
		float et = 1.1;//material.refracti;
		bool entering = dot(path.ray.direction, intersect.hitNormal) < 0;
		if (!entering) {
			float t = ei;
			ei = et;
			et = t;
		}

		float eta = ei / et;
		path.ray.direction = normalize(refract(path.ray.direction, intersect.hitNormal, eta));
		path.ray.origin = intersect.hitPoint + 0.001 * path.ray.direction;
		path.remainingBounces--;
		path.color *= clamp(abs(dot(path.ray.direction, intersect.hitNormal)), 0, 1) * vec3(1, 1, 1) * 0.1;

	} else {
		path.remainingBounces = 0;
	}

	//path.ray.direction = normalize(reflect(path.ray.direction, intersect.hitNormal));
	//path.ray.origin = intersect.hitPoint + 0.01 * path.ray.direction;


}

vec3 renderScene(inout PathSegment path)
{
	
	return path.color;
}

// Generate ray ========================

void main()
{

	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
	
	// Extract parameters from textures
	vec3 position = texture(positionsImage, uv).rgb;
	
	// Here, materialId was normalized and packed as the fourth value
	float materialIdNormalized = texture(positionsImage, uv).w;
	int materialId = int(materialIdNormalized * float(ubo.materialCount));
	vec3 normal = texture(normalsImage, uv).rgb;

	// @todo: for now, store albedo here
	vec3 diffuseColor = texture(materialIDsImage, uv).rgb;

	// Terminate early if we didn't hit anything!
	if (diffuseColor.r == 0 && diffuseColor.r == 0 && diffuseColor.r == 0) {
		imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(0, 0, 0, 1.0));
		return;	 
	}

	PathSegment path;
	path.remainingBounces = TRACEDEPTH;
	path.shouldTerminate = false;
	path.ray.direction = normalize(position - vec3(ubo.cameraPosition));
	path.ray.origin = position + 0.01 * path.ray.direction;
	path.color = vec3(0,0,0);
	path.objectId = materialId; // Use material ID as object ID
	
	Intersection intersection;
	intersection.hitPoint = position;
	intersection.hitNormal = normal;
	intersection.materialId = materialId;
	intersection.t = 1;

	// Shade and reflect
	shadeMaterial(intersection, path);

	// Trace ray
	while(path.remainingBounces > 0) {
		
		intersection = computeIntersections(path);
		shadeMaterial(intersection, path);
	}

	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(path.color, 1.0));
}